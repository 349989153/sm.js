/**
 * SM2 elliptic curve
 *
 * Support SM2 key pair generation and signature.
 */


var SM3 = require('./SM3');
var utils = require('./utils');
var elliptic = require('elliptic');
var BN = require('bn.js');
var inherits = require('inherits');
var DRBG = require('hmac-drbg');
var hash = require('hash.js');

var Base = elliptic.curve.short;

var drbg = new DRBG({
  hash: hash.sha256,
  entropy: 'UQi4W3Y2bJfzleYy+oEZ2kA9A+9jrmwewST9vmBZNgMmFyzzH0S9Vol/UK',
  nonce: 'UQi4W3Y2bJfzleYy+oEZ2kA9A+9jrmwewST9vmBZNgMmFyzzH0S9Vol/UK',
  pers: '0123456789abcdef'
});


/**
 * Define the SM2 curve object
 * @constructor
 */
function SM2() {
  if (!(this instanceof SM2)) {
    return new SM2();
  }
  Base.call(this, _SM2Params);
}
inherits(SM2, Base);
module.exports = SM2;


const _SM2Params = {
  type: 'SM2',
  prime: null,
  p: 'FFFFFFFE FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 00000000 FFFFFFFF FFFFFFFF',
  a: 'FFFFFFFE FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 00000000 FFFFFFFF FFFFFFFC',
  b: '28E9FA9E 9D9F5E34 4D5A9E4B CF6509A7 F39789F5 15AB8F92 DDBCBD41 4D940E93',
  n: 'FFFFFFFE FFFFFFFF FFFFFFFF FFFFFFFF 7203DF6B 21C6052B 53BBF409 39D54123',
  hash: SM3,
  gRed: false,
  g: [
    '32C4AE2C 1F198119 5F990446 6A39C994 8FE30BBF F2660BE1 715A4589 334C74C7',
    'BC3736A2 F4F6779C 59BDCEE3 6B692153 D0A9877C C62A4740 02DF32E5 2139F0A0'
  ]

}

/**
 * Generate a SM2 key pair
 */
SM2.prototype.genKeyPair = function() {
  var pri = 0;
  var limit = this.n.sub(new BN(2));
  // generate 32 bytes private key in range [1, n-1]
  do {
    pri = new BN(drbg.generate(32, 'hex'));
  } while (pri.cmp(limit) > 0);

  // calculate public key
  pub = this.g.mul(pri);

  return new SM2KeyPair(this, pub, pri);
}


/**
 * Constructe key pair
 * @constructor
 */
function SM2KeyPair(curve, pub, pri) {
  if (!(this instanceof SM2KeyPair)) {
    return new SM2KeyPair();
  }
  this.curve = curve; // curve parameter
  this.pub = pub; // public key, should be a point on the curve
  this.pri = pri; // private key, should be a integer
}

/**
 * Check whether the public key is valid
 */
SM2KeyPair.prototype.validate = function() {
  if (this.pub.isInfinity()) {
    return false
  }

  //TODO
}

/**
 * Generate signature to the message
 *
 * The input message will combine with extras(a constant user id, the
 * curve parameters and public key), and use SM3 hashing function to
 * generate digest.
 *
 * @param {string|byte array} msg
 *
 * @return {object} Signature (r, s). Both part is a hex string.
 */
SM2KeyPair.prototype.sign = function(msg) {
  //var cm = this._combine(msg);
  //var digest = new SM3().sum(cm);
  if (typeof msg === 'string')
    return this.signHash(new SM3().sum(this._combine(utils.strToBytes(msg))));
  else
    return this.signHash(new SM3().sum(this._combine(msg)));
}

/**
 * Verify the signature (r,s)
 *
 * @param {string|byte array} msg
 * @param {string} r - signature.r part in hex string
 * @param {string} s - signature.s part in hex string
 *
 * @return {bool} true if verification passed.
 */
SM2KeyPair.prototype.verify = function(msg, r, s) {
  if (typeof msg === 'string')
    return this.verifyHash(new SM3().sum(this._combine(utils.strToBytes(msg))), r, s);
  else
    return this.verifyHash(new SM3().sum(this._combine(msg)), r, s);
}

/**
 * Generate signature to the message without combination with extras.
 */
SM2KeyPair.prototype.signRaw = function(msg) {
  if (typeof msg == 'string')
    return this.signHash(new SM3().sum(utils.strToBytes(msg)));
  else
    return this.signHash(new SM3().sum(msg));
}

/**
 * Verify signature (r, s) generated by signRaw()
 */
SM2KeyPair.prototype.verifyRaw = function(msg, r, s) {
  if (typeof msg == 'string')
    return this.verifyHash(new SM3().sum(utils.strToBytes(msg)), r, s);
  else
    return this.verifyHash(new SM3().sum(msg), r, s);
}

/**
 * Generate signature for the message digest
 *
 * The input data should be a 256bits hash digest.
 *
 * @param {string|byte array} hash - the digest of the message
 * @return {object}  signature with r and s parts
 */
SM2KeyPair.prototype.signHash = function(hash) {
  var signature = {
    r: "",
    s: ""
  }

  //console.log("start sign");
  //console.log("n =", this.curve.n.toString(16));

  while (true) {
    var k = new BN(drbg.generate(32, 'hex'), 16).umod(this.curve.n);
    var kg = this.curve.g.mul(k);
    var r = utils.hashToBN(hash).add(kg.getX()).umod(this.curve.n);

    console.log("k =", k.toString());
    //console.log("kg.x =", kg.getX().toString());
    //console.log("e =", h.toString());
    //console.log("x + e mod n =", r.toString());

    // r = 0
    if (r.isZero()) {
      continue;
    }
    // r + k = n
    if (r.add(k).eq(this.curve.n)) {
      continue;
    }

    var t1 = new BN(1).add(this.pri).invm(this.curve.n);
    var t2 = k.sub(r.mul(this.pri)).umod(this.curve.n);
    var s = t1.mul(t2).umod(this.curve.n);
    if (!s.isZero()) {
      signature.r = r.toString(16);
      signature.s = s.toString(16);
      break;
    }
  }

  return signature;
}


/**
 * Verify the signature to the digest
 *
 * @param {string|byte array} hash - digest of the message
 * @param {string} r - hex string of signature.r
 * @param {string} s - hex string of signature.s
 *
 * @return {bool} true if verification passed
 */
SM2KeyPair.prototype.verifyHash = function(hash, r, s) {
  //console.log("start verify");
  //console.log(hash);

  var bnr = new BN(r, 16);
  if (bnr.cmp(this.curve.n) >= 0) {
    return false;
  }
  //console.log("r =", bnr.toString(16));

  var bns = new BN(s, 16);
  if (bns.cmp(this.curve.n) >= 0) {
    return false;
  }
  //console.log("s =", bns.toString(16));

  var t = bnr.add(bns).umod(this.curve.n);
  if (t.isZero()) {
    return false;
  }
  //console.log("t =", t.toString(16));

  var q = this.curve.g.mul(bns).add(this.pub.mul(t));
  //console.log("Q =", q.getX().toString(), q.getY().toString());
  var R = utils.hashToBN(hash).add(q.getX()).umod(this.curve.n);
  //console.log("R =", R.toString(16));
  if (!R.eq(bnr)) {
    return false;
  }

  return true;
}

SM2KeyPair.prototype._combine = function(msg) {
  var za = [0x00, 0x80, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8];
  za = za.concat(this.curve.a.toArray());
  za = za.concat(this.curve.b.toArray());
  za = za.concat(this.curve.g.getX().toArray());
  za = za.concat(this.curve.g.getY().toArray());
  za = za.concat(this.pub.getX().toArray());
  za = za.concat(this.pub.getY().toArray());

  h = new SM3();
  za = h.sum(za);

  return za.concat(msg);
}

SM2KeyPair.prototype.toString = function() {
  var s = "";
  s += "public: (" + this.pub.getX().toString(16)
    + ", " + this.pub.getY().toString(16) + "), ";
  s += "private: " + this.pri.toString(16);
  return s;
}

SM2KeyPair.prototype.fromJSON = function(curve, json) {
  //TODO
}

